{"version":3,"file":"responsive-activation.js","sourceRoot":"","sources":["responsive-activation.ts"],"names":[],"mappings":"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","sourcesContent":["import {Directive} from '@angular/core';\n\nimport {Subscription} from 'rxjs/Subscription';\nimport 'rxjs/add/operator/map';\nimport {extendObject} from '../../utils/object-extend';\n\nimport {MediaChange, MediaQuerySubscriber} from '../../media-query/media-change';\nimport {BreakPoint} from '../../media-query/breakpoints/break-point';\nimport {MediaMonitor} from '../../media-query/media-monitor';\n\n/** @internal  */\nexport declare type SubscriptionList = Subscription[ ];\n\n/** @internal  */\nexport interface BreakPointX extends BreakPoint{\n  key : string;\n  baseKey : string;\n}\n\n/** @internal  */\nexport class KeyOptions {\n  constructor(\n    public baseKey : string,\n    public defaultValue : string|number|boolean,\n    public inputKeys:{[key:string]:any}) { }\n}\n\n/**\n * @internal\n *\n * ResponsiveActivation acts as a proxy between the MonitorMedia service (which emits mediaQuery changes)\n * and the fx API directives. The MQA proxies mediaQuery change events and notifies the directive\n * via the specified callback.\n *\n * - The MQA also determines which directive property should be used to determine the\n *   current change 'value'... BEFORE the original `onMediaQueryChanges()` method is called.\n * - The `ngOnDestroy()` method is also head-hooked to enable auto-unsubscribe from the MediaQueryServices.\n *\n * NOTE: these interceptions enables the logic in the fx API directives to remain terse and clean.\n */\nexport class ResponsiveActivation {\n  private _subscribers : SubscriptionList = [ ];\n  private _activatedInputKey: string;\n\n  /**\n   * Constructor\n   */\n  constructor(\n      private _options : KeyOptions,\n      private _mediaMonitor: MediaMonitor,\n      private _onMediaChanges : MediaQuerySubscriber )\n  {\n    this._subscribers = this._configureChangeObservers();\n  }\n\n  /**\n   * Accessor to the DI'ed directive property\n   * Each directive instance has a reference to the MediaMonitor which is\n   * used HERE to subscribe to mediaQuery change notifications.\n   */\n  get mediaMonitor() : MediaMonitor {\n    return this._mediaMonitor;\n  }\n\n  /**\n   * Determine which directive @Input() property is currently active (for the viewport size):\n   * The key must be defined (in use) or fallback to the 'closest' overlapping property key\n   * that is defined; otherwise the default property key will be used.\n   * e.g.\n   *      if `<div fxHide fxHide.gt-sm=\"false\">` is used but the current activated mediaQuery alias\n   *      key is `.md` then `.gt-sm` should be used instead\n   */\n  get activatedInputKey(): string {\n    return this._activatedInputKey || this._options.baseKey;\n  }\n\n  /**\n   * Get the currently activated @Input value or the fallback default @Input value\n   */\n  get activatedInput(): any {\n    let key = this.activatedInputKey;\n    return this._hasKeyValue(key) ? this._lookupKeyValue(key) : this._options.defaultValue;\n  }\n\n  /**\n   * Remove interceptors, restore original functions, and forward the onDestroy() call\n   */\n  destroy() {\n    this._subscribers.forEach((link: Subscription) => {\n      link.unsubscribe();\n    });\n    this._subscribers = [ ];\n  }\n\n  /**\n   * For each *defined* API property, register a callback to `_onMonitorEvents( )`\n   * Cache 1..n subscriptions for internal auto-unsubscribes when the the directive destructs\n   */\n  private _configureChangeObservers(): SubscriptionList {\n    let subscriptions = [];\n\n    this._buildRegistryMap().forEach((bp:BreakPointX)=> {\n      if ( this._keyInUse(bp.key) ) {\n        // Inject directive default property key name: to let onMediaChange() calls\n        // know which property is being triggered...\n        let buildChanges = (change: MediaChange) => {\n              change.property = this._options.baseKey;\n              return change;\n            };\n\n        subscriptions.push(\n          this.mediaMonitor.observe(bp.alias)\n              .map(buildChanges)\n              .subscribe(change => {\n                this._onMonitorEvents(change);\n              })\n        );\n      }\n    });\n\n    return subscriptions;\n  }\n\n  /**\n   * Build mediaQuery key-hashmap; only for the directive properties that are actually defined/used\n   * in the HTML markup\n   */\n  private _buildRegistryMap() {\n    return this.mediaMonitor.breakpoints\n        .map(bp => {\n          return <BreakPointX> extendObject({}, bp, {\n            baseKey : this._options.baseKey,              // e.g.  layout, hide, self-align, flex-wrap\n            key     : this._options.baseKey + bp.suffix   // e.g.  layoutGtSm, layoutMd, layoutGtLg\n          });\n        })\n        .filter( bp => this._keyInUse(bp.key) );\n  }\n\n  /**\n   * Synchronizes change notifications with the current mq-activated @Input and calculates the\n   * mq-activated input value or the default value\n   */\n  _onMonitorEvents(change: MediaChange) {\n    if ( change.property == this._options.baseKey ) {\n      change.value = this._calculateActivatedValue(change);\n\n      this._onMediaChanges(change);\n    }\n  }\n\n  /**\n   * Has the key been specified in the HTML markup and thus is intended\n   * to participate in activation processes.\n   */\n  private _keyInUse(key ):boolean {\n    return this._lookupKeyValue(key) !== undefined;\n  }\n\n  /**\n   *  Map input key associated with mediaQuery activation to closest defined input key\n   *  then return the values associated with the targeted input property\n   *\n   *  !! change events may arrive out-of-order (activate before deactivate)\n   *     so make sure the deactivate is used ONLY when the keys match\n   *     (since a different activate may be in use)\n   */\n  private _calculateActivatedValue(current:MediaChange): any  {\n    const currentKey = this._options.baseKey + current.suffix;    // e.g. suffix == 'GtSm', _baseKey == 'hide'\n    let   newKey = this._activatedInputKey;                     // e.g. newKey == hideGtSm\n\n          newKey = current.matches ? currentKey : ((newKey == currentKey) ? null : newKey);\n\n    this._activatedInputKey = this._validateInputKey(newKey);\n    return this.activatedInput;\n  }\n\n  /**\n   * For the specified input property key, validate it is defined (used in the markup)\n   * If not see if a overlapping mediaQuery-related input key fallback has been defined\n   *\n   * NOTE: scans in the order defined by activeOverLaps (largest viewport ranges -> smallest ranges)\n   */\n  private _validateInputKey(inputKey) {\n    let items: BreakPoint[] = this.mediaMonitor.activeOverlaps;\n    let isMissingKey = (key) => !this._keyInUse(key);\n\n    if ( isMissingKey( inputKey ) ) {\n      items.some( bp => {\n        let key = this._options.baseKey + bp.suffix;\n        if ( !isMissingKey(key) ) {\n          inputKey = key;\n          return true;  // exit .some()\n        }\n        return false;\n      });\n    }\n    return inputKey;\n  }\n\n  /**\n   * Get the value (if any) for the directive instances @Input property (aka key)\n   */\n  private _lookupKeyValue(key) {\n    return this._options.inputKeys[key];\n  }\n\n  private _hasKeyValue(key) {\n    let value = this._options.inputKeys[key];\n    return typeof value !== 'undefined';\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}