{"version":3,"file":"observable-media-service.js","sourceRoot":"","sources":["observable-media-service.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Injectable} from '@angular/core';\n\nimport {Subscription} from 'rxjs/Subscription';\nimport {Observable, Subscribable} from \"rxjs/Observable\";\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/filter';\n\nimport {BreakPointRegistry} from './breakpoints/break-point-registry';\n\nimport {MediaChange} from './media-change';\nimport {MatchMedia} from './match-media';\nimport {mergeAlias} from './../utils/add-alias';\nimport {BreakPoint} from './breakpoints/break-point';\n\n/**\n * Base class for MediaService and pseudo-token for\n */\nexport abstract class ObservableMedia implements Subscribable<MediaChange> {\n  abstract isActive(query: string): boolean;\n\n  abstract asObservable(): Observable<MediaChange>;\n\n  abstract subscribe(next?: (value: MediaChange) => void,\n                     error?: (error: any) => void,\n                     complete?: () => void): Subscription;\n}\n\n/**\n * Class internalizes a MatchMedia service and exposes an Subscribable and Observable interface.\n\n * This an Observable with that exposes a feature to subscribe to mediaQuery\n * changes and a validator method (`isActive(<alias>)`) to test if a mediaQuery (or alias) is\n * currently active.\n *\n * !! Only mediaChange activations (not de-activations) are announced by the ObservableMedia\n *\n * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange\n * notification. For custom mediaQuery notifications, alias information will not be injected and\n * those fields will be ''.\n *\n * !! This is not an actual Observable. It is a wrapper of an Observable used to publish additional\n * methods like `isActive(<alias>). To access the Observable and use RxJS operators, use\n * `.asObservable()` with syntax like media.asObservable().map(....).\n *\n *  @usage\n *\n *  // RxJS\n *  import 'rxjs/add/operator/filter';\n *  import { ObservableMedia } from '@angular/flex-layout';\n *\n *  @Component({ ... })\n *  export class AppComponent {\n *    status : string = '';\n *\n *    constructor(  media:ObservableMedia ) {\n *      let onChange = (change:MediaChange) => {\n *        this.status = change ? `'${change.mqAlias}' = (${change.mediaQuery})` : \"\";\n *      };\n *\n *      // Subscribe directly or access observable to use filter/map operators\n *      // e.g.\n *      //      media.subscribe(onChange);\n *\n *      media.asObservable()\n *        .filter((change:MediaChange) => true)   // silly noop filter\n *        .subscribe(onChange);\n *    }\n *  }\n */\n\nexport class MediaService implements ObservableMedia {\n  /**\n   * Should we announce gt-<xxx> breakpoint activations ?\n   */\n  public filterOverlaps = true;\n\n  constructor(private mediaWatcher: MatchMedia,\n              private breakpoints: BreakPointRegistry) {\n    this.observable$ = this._buildObservable();\n    this._registerBreakPoints();\n  }\n\n  /**\n   * Test if specified query/alias is active.\n   */\n  isActive(alias): boolean {\n    let query = this._toMediaQuery(alias);\n    return this.mediaWatcher.isActive(query);\n  };\n\n  /**\n   * Proxy to the Observable subscribe method\n   */\n  subscribe(next?: (value: MediaChange) => void,\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n    return this.observable$.subscribe(next, error, complete);\n  };\n\n  /**\n   * Access to observable for use with operators like\n   * .filter(), .map(), etc.\n   */\n  asObservable(): Observable<MediaChange> {\n    return this.observable$;\n  }\n\n  // ************************************************\n  // Internal Methods\n  // ************************************************\n\n  /**\n   * Register all the mediaQueries registered in the BreakPointRegistry\n   * This is needed so subscribers can be auto-notified of all standard, registered\n   * mediaQuery activations\n   */\n  private _registerBreakPoints() {\n    this.breakpoints.items.forEach((bp: BreakPoint) => {\n      this.mediaWatcher.registerQuery(bp.mediaQuery);\n      return bp;\n    });\n  }\n\n  /**\n   * Prepare internal observable\n   * NOTE: the raw MediaChange events [from MatchMedia] do not contain important alias information\n   * these must be injected into the MediaChange\n   */\n  private _buildObservable() {\n    return this.mediaWatcher.observe()\n        .filter((change: MediaChange) => {\n          // Only pass/announce activations (not de-activations)\n          return change.matches === true;\n        })\n        .map((change: MediaChange) => {\n          // Inject associated (if any) alias information into the MediaChange event\n          return mergeAlias(change, this._findByQuery(change.mediaQuery));\n        })\n        .filter((change: MediaChange) => {\n          let bp = this.breakpoints.findByQuery(change.mediaQuery);\n          return !bp ? true : !(this.filterOverlaps && bp.overlapping);\n        });\n  }\n\n  /**\n   * Breakpoint locator by alias\n   */\n  private _findByAlias(alias) {\n    return this.breakpoints.findByAlias(alias);\n  }\n\n  /**\n   * Breakpoint locator by mediaQuery\n   */\n  private _findByQuery(query) {\n    return this.breakpoints.findByQuery(query);\n  };\n\n  /**\n   * Find associated breakpoint (if any)\n   */\n  private _toMediaQuery(query) {\n    let bp: BreakPoint = this._findByAlias(query) || this._findByQuery(query);\n    return bp ? bp.mediaQuery : query;\n  };\n\n  private observable$: Observable<MediaChange>;\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: MatchMedia, },\n{type: BreakPointRegistry, },\n];\n}\n\n/**\n *  Provider to return observable to ALL MediaQuery events\n *  Developers should build custom providers to override this default MediaQuery Observable\n */\nexport const ObservableMediaProvider = { // tslint:disable-line:variable-name\n  provide: ObservableMedia,\n  useClass: MediaService,\n  deps: [MatchMedia, BreakPointRegistry]\n};\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}